---
title: Webview in Chat
---

We have learned how to ship features in a conversation. But sometimes chat UIs
are not very suitable for all the features.
In this lesson, you'll learn how to open an embeded webview and integrate it
with your bot.

>　Time to accomplish: 10 minutes

### Entry to Webview

Most chat platforms need special API to display an embedded webview in the
chatroom. Follow the guide of the platform you choose to add a button for
opening webview:

<Tabs
  groupId="chat-platforms"
  defaultValue="messenger"
  values={[
    {label: 'Messenger', value: 'messenger'},
    {label: 'Telegram', value: 'telegram'},
    {label: 'LINE', value: 'line'},
  ]}>
  <TabItem value="messenger">

Add the following codes in the `WithMenu` component:

```tsx {4,20,28-38} title="src/components/WithMenu.tsx"
import Machinat, { MachinatNode } from '@machinat/core';
import * as Messenger from '@machinat/messenger/components';

const { DOMAIN } = process.env;

type WithMenuProps = {
  children: MachinatNode;
  todoCount: number;
};

const WithMenu =  (
  { children, todoCount }: WithMenuProps,
  { platform }
) => {
  const info = <>You have <b>{todoCount}</b> todos now.</>;

  const listLabel = 'Show Todos 📑';
  const listData = JSON.stringify({ type: 'list' });

  const editLabel = 'Edit 📤';

  if (platform === 'messenger') {
    return (
      <>
        {children}
        <Messenger.ButtonTemplate
            buttons={
              <>
                  <Messenger.PostbackButton
                    title={listLabel}
                    payload={listData}
                  />
                  <Messenger.UrlButton
                    messengerExtensions
                    title={editLabel}
                    url={`https://${DOMAIN}/webview?platform=messenger`}
                  />
              </>
            }
        >
            {info}
        </Messenger.ButtonTemplate>
      </>
    );
  }

  return <>{children}{info}</>;
}

export default WithMenu;
```

`Messenger.UrlButton` component add a button that opens a web page when user tap it.
The `messengerExtensions` prop need to be set for user login in the webview.

`url` prop link to the `/webview` endpoint where our web server is located
at. And the `platform=messenger` querystring tells webview client to adopt
`messenger` platform for login.

  </TabItem>
  <TabItem value="telegram">

Add the following codes in the `WithMenu` component:

```tsx {4,20,30-34} title="src/components/WithMenu.tsx"
import Machinat, { MachinatNode } from '@machinat/core';
import * as Telegram from '@machinat/telegram/components';

const { DOMAIN } = process.env;

type WithMenuProps = {
  children: MachinatNode;
  todoCount: number;
};

const WithMenu =  (
  { children, todoCount }: WithMenuProps,
  { platform }
) => {
  const info = <>You have <b>{todoCount}</b> todos now.</>;

  const listLabel = 'Show Todos 📑';
  const listData = JSON.stringify({ type: 'list' });

  const editLabel = 'Edit 📤';

  if (platform === 'telegram') {
    return (
      <>
        {children}
        <Telegram.Text
          replyMarkup={
            <Telegram.InlineKeyboard>
              <Telegram.CallbackButton text={listLabel} data={listData} />
              <Telegram.UrlButton
                login
                text={editLabel}
                url={`https://${DOMAIN}/auth/telegram`}
              />
            </Telegram.InlineKeyboard>
          }
        >
          {info}
        </Telegram.Text>
      </>
    );
  }

  return <>{children}{info}</>;
}

export default WithMenu;
```

`Telegram.UrlButton` component add a button that opens a web page when user tap it.
The `login` prop need to be set for user login in the webview.

`url` prop link to `/auth/telegram` endpoint for verifying [telegram login](https://telegram.org/blog/privacy-discussions-web-bots#meet-seamless-web-bots)
data. If login succeed, user will be redirected to the `/webview` endpoint where
our web server is located at.

  </TabItem>
  <TabItem value="line">

  Add the following codes in the `WithMenu` component:

```tsx {4,20,29-35} title="src/components/WithMenu.tsx"
import Machinat, { MachinatNode } from '@machinat/core';
import * as Line from '@machinat/line/components';

const { LINE_LIFF_ID } = process.env;

type WithMenuProps = {
  children: MachinatNode;
  todoCount: number;
};

const WithMenu =  (
  { children, todoCount }: WithMenuProps,
  { platform }
) => {
  const info = <>You have <b>{todoCount}</b> todos now.</>;

  const listLabel = 'Show Todos 📑';
  const listData = JSON.stringify({ type: 'list' });

  const editLabel = 'Edit 📤';

  if (platform === 'line') {
    return (
      <>
        {children}
        <Line.ButtonTemplate
          altText={`You have ${todoCount} todos now.`}
          actions={
            <>
              <Line.PostbackAction label={listLabel} data={listData} />
              <Line.UriAction
                label={editLabel}
                uri={`https://liff.line.me/${LINE_LIFF_ID}`}
              />
            </>
          }
        >
          {info}
        </Line.ButtonTemplate>
      </>
    );
  }

  return <>{children}{info}</>;
}

export default WithMenu;
```

`Line.UriAction` component add a button that opens a web page when user tap it.
`uri` prop link to the [LINE liff app](https://developers.line.biz/en/docs/liff/overview/)
we created in lesson 1 with `https://{DOMAIN}/webview?platform=line`  url.

LINE server would redirect user to `/webview` endpoint where our web
server is located at. And the `platform=line` querystring tells webview client to
adopt `line` platform for login.

  </TabItem>
</Tabs>


Now an `Edit 📤` button should be added in the root menu like this:

<img width={400} src={require("./assets/webview-button.png").default} />

Try tap the button and you should see the default webview is already working!


### Webview Client

The web front-end codes of the webview is located at `src/webview/` folder. Check
`src/webview/pages/index.tsx` file and you shoud see the webview client is
contstructed like this:


```tsx title="src/webview/pages/index.tsx"
// ...
const client = new WebviewClient(
  typeof window === 'undefined'
    ? { mockupMode: true, authorizers: [] }
    : {
        authorizers: [
          new MessengerClientAuthorizer({
            appId: publicRuntimeConfig.messengerAppId,
          }),
          new TelegramClientAuthorizer(),
          new LineClientAuthorizer({
            liffId: publicRuntimeConfig.lineLiffId,
          }),
        ],
      }
);
// ...
```

When a webview page is opened, the `client` would do this two things:

1. Log in user to the chosen chat platform. With the user info, we can provide
   features that integrated with chatroom.

2. Create a `WebSocket` connection to communicate with server. We can then use
   client to send events to server and receive event from it.

### Webview Page

Let's try display the todos in webview. Edit the `WebAppHome` page function like
this:

```tsx title="src/webview/pages/index.tsx"
// ...
const WebAppHome = () => {
  const data = useEventReducer(
    client,
    (currentData: null | TodoState, { event }): null | TodoState => {
      if (event.type === 'app_data') {
        return event.payload.data;
      }
      return currentData;
    },
    null
  );

  return (
    <div>
      <Head>
        <title>Edit Todos</title>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css"
        />
      </Head>

      <main>
        <h4>You have {data ? data.todos.length : '?'} Todo:</h4>
        <table>
          <tbody>
            {data?.todos.map((todo) => <tr><td>{todo.name}</td></tr>)}
          </tbody>
        </table>

        <h4>You have {data ? data.finishedTodos.length : '?'} finished Todo:</h4>
        <table>
          <tbody>
            {data?.finishedTodos.map((todo) => <tr><td>{todo.name}</td></tr>)}
          </tbody>
        </table>
      </main>
    </div>
  );
};
// ...
```

:::info
The JSX syntax in the web front-end is [React.js](https://reactjs.org) element.
While the _Machinat_ JSX elements are rendered into chat messages, the _React_
JSX elements are rendered into html content of the web page.
:::


The `useEventReducer` [hook](https://reactjs.org/docs/hooks-reference.htm)
is the simplest way to handle events from server. Every time a event is received,
the reducer function would be called to update data and the view.

```ts
const data = useEventReducer(client, reducerFn, initialValue);
```

Before the `'app_data'` event from server is recevied, the data value would be
`null`. Try open the webview now and you should see the page without todos:


<img width={500} src={require("./assets/webview-1.png").default} />


### Handle Event From Server

On the server side, the events from client side are received just like other
chat platforms. To send todos data to front-end, edit the `handleWebview`
handler like this:

```tsx title="src/handlers/handleWebview.tsx"
import { makeContainer } from '@machinat/core/service';
import TodoController from '../services/TodoController';
import { WebAppEventContext } from '../types';

const handleWebview = makeContainer({
  deps: [TodoController],
})(
  (todoController) =>
    async ({ event, bot, metadata: { auth } }: WebAppEventContext) => {
      if (event.type === 'connect') {
        const { data } = await todoController.getTodos(auth.channel);

        return bot.send(event.channel, {
          category: 'webview_push',
          type: 'app_data',
          payload: { data },
        });
      }
    }
);

export default handleWebview;
```

After a webview connection is established, our app would receive a
`'connect'` event. `event.channel` here refer to a connection to the webcview client.
We can use `bot.send(connection, eventObj)` method to send the data to client side.

The `metadata.auth` object contains the authorization infos about the connection.
`auth.channel` here refer to the original chatroom where user comes from.
We can use it to get the todos data of the chat with `TodoController`.

Now the webview should display the todos you have like this:

<img width={500} src={require("./assets/webview-2.png").default} />


### Send Event on Client Side

The webview is good for serving more complex view and operation. We can easily
add a button to delete the todo by adding these codes:

```tsx {2-19,35,40,47} title="src/webview/pages/index.tsx"
// ...
const TodoRow = ({ todo }) => (
    <tr>
      <td style={{ verticalAlign: 'middle' }}>{todo.name}</td>
      <td style={{ textAlign: 'right' }}>
        <button
          onClick={() => {
            client.send({
              category: 'webview_action',
              type: 'delete_todo',
              payload: { id: todo.id },
            })
          }}
        >
          ❌
        </button>
      </td>
    </tr>
);

const WebAppHome = () => {
  // ...

  return (
    <div>
      <Head>
        <title>Edit Todos</title>
        <link
          rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css"
        />
      </Head>

      <main>
        <h3>Press ❌ to delete todos</h3>

        <h4>You have {data ? data.todos.length : '?'} Todo:</h4>
        <table>
          <tbody>
            {data?.todos.map((todo) => <TodoRow todo={todo} />)}
          </tbody>
        </table>

        <h4>You have {data ? data.finishedTodos.length : '?'} finished Todo:</h4>
        <table>
          <tbody>
            {data?.finishedTodos.map((todo) => <TodoRow todo={todo} />)}
          </tbody>
        </table>
      </main>
    </div>
  );
};
//...
```

In the new `TodoRow` component, we add a `❌` button to delete todo.
Our webview should look like this now:

<img width={500} src={require("./assets/webview-3.png").default} />

When the button is clicked by user, we use `client.send(eventObj)` method to send
a `'delete_todo'` event to server. We can receive it on server side this way:


```tsx title="src/handlers/handleWebview.tsx"
const handleWebview = makeContainer({ deps: [TodoController] })(
  // ...
  if (event.type === 'delete_todo') {
    const { todo } = await todoController.deleteTodo(
      auth.channel,
      event.payload.id
    );

    if (todo) {
      return bot.send(event.channel, {
        category: 'webview_push',
        type: 'todo_deleted',
        payload: { todo },
      });
    }
  }
  //...
```

The todo is deleted from the state when a `'delete_todo'` event is received.
Then we push a `'todo_deleted'` response to notify client that the action is
succeeded.

Finally in the front-end, we receive the response and update the data and view
like this:

```tsx {9-17} title="src/webview/pages/index.tsx"
const WebAppHome = () => {
  const data = useEventReducer(
    client,
    (currentData: null | TodoState, { event }): null | TodoState => {
      if (event.type === 'app_data') {
        return event.payload.data;
      }

      if (currentData && event.type === 'todo_deleted') {
        const { id } = event.payload.todo;
        const { todos, finishedTodos } = currentData;
        return {
          ...currentData,
          todos: todos.filter((todo) => todo.id !== id),
          finishedTodos: finishedTodos.filter((todo) => todo.id !== id),
        };
      }

      return data;
    },
    null
  );
  // ...
```

Now the todos can be deleted in the webview like this:

<video width={450} autoplay="autoplay" loop inline>
  <source src={require("./assets/webview-delete.webm").default} type="video/webm" />
</video>
